#pragma once
/*
日期：2018.12.18
名称：计算器1.0
更新日志：1.完成了正整数的加减乘除及阶乘运算，其中除法精度可调，即带余除法和可变精度的小数除法。
*/
#include<stdio.h>
#include<string.h>
#include<ctype.h>
#define N 500
/********************************************************
	监视函数
	用来监视整个数组内部
	debug用
*********************************************************/
void monitor(int x[], int length)
{
	for (int i = 0; i < length; i++)
		printf("%d ", x[i]);
	printf("\n");
}
/********************************************************
	输入函数
	字符串输入
	利用指针来寻找运算符
	将操作数倒序输入两个数组中
	其中，数组的0位作为数位的存储
	最后返回运算符
*********************************************************/
char input(int x[], int y[],int *n)
{
	char *ch, operation[2 * N + 2] = { 0 };
	scanf("%s", operation);
	for (ch = operation; isdigit(*ch); ch++);//标记运算符的位置
	if (*ch == '!')//判断是否为阶乘运算，单独处理
	{
		int i;
		x[0] = (int)(ch - operation);
		for (i = 0; i < x[0]; i++)
			x[x[0] - i] = operation[i] - '0';
		sscanf(operation, "%d", n);//将需计算的阶乘操作数用两种方式存储，单精度和高精度
	}
	else
	{
		int i, length = (int)strlen(operation);
		x[0] = (int)(ch - operation);
		y[0] = length - x[0] - 1;
		for (i = 0; i < x[0]; i++)
			x[x[0] - i] = operation[i] - '0';
		for (i++; i < length; i++)
			y[y[0] - i + x[0] + 1] = operation[i] - '0';
	}
	return *ch;
}/********************************************************
	输出函数
	不解释
*********************************************************/
void output(int x[])
{
	for (int i = x[0]; i >= 1; i--)
		(x[i] != -1) ? printf("%d", x[i]) : printf(".");
}
/********************************************************
	比较函数
	返回哪一个数较大，便于减法的符号输出
*********************************************************/
bool compare(int L[], int R[]) //实现两个高精度数字的大小比较 
{
	if (L[0] > R[0])return true;//位数高的大
	if (L[0] < R[0])return false;//位数低的小
	int i;
	for (i = L[0]; i >= 1; i--)//位数相同逐位比较
	{
		if (L[i] > R[i])return true;//数字大的大
		if (L[i] < R[i])return false;//数字小的小
	}
	return true;//能执行到这里说明相等，返回true
}
/********************************************************
	加法
	逢十进一，模拟手工
	注意最后的数位更新
*********************************************************/
void plus(int x[], int y[])
{
	int i;
	for (i = 1; i <= x[0] || i <= y[0]; i++)//注意跳出条件
	{
		x[i + 1] += (x[i] + y[i]) / 10;
		x[i] = (x[i] + y[i]) % 10;
	}
	x[0] = (x[0] > y[0]) ? x[0] : y[0];
	(x[i] > 0) ? x[0]++ : x[0];//判断是否最后一位是否进位
}
/********************************************************
	减法
	大减小
	注意最后检查全零的情况，并更改数位
*********************************************************/
void minus(int x[], int y[])//大减小的减法，小减大会出问题
{
	int i;
	for (i = 1; i <= x[0]; i++)
	{
		if (x[i] < y[i])
		{
			x[i + 1]--;
			x[i] += 10;
		}
		x[i] -= y[i];
	}
	while (x[i] == 0 && i >= 1)i--;
	x[0] = (i == 0) ? 1 : i;//考虑全零的情况
}
/********************************************************
	乘法
	逢十进一，模拟手工
	注意最后的数位更新
*********************************************************/
void multiply(int x[], int y[], int z[])
{
	int i, j;
	for (i = 1; i <= x[0]; i++)
		for (j = 1; j <= y[0]; j++)
			z[i + j - 1] += x[i] * y[j];//注意手工乘法相应的数位增减
	for (i = 1; i <= x[0] + y[0]; i++)//统一进位循环
	{
		z[i + 1] += z[i] / 10;
		z[i] %= 10;
	}
	z[0] = x[0] + y[0] + ((z[i] > 0) ? 1 : 0);//用来计算最终结果的位数
}
/********************************************************
	单精度乘法
*********************************************************/
void single_precision_multiply(int x[], int y)
{
	int i;
	for (i = 1; i <= x[0]; i++)
		x[i] *= y;
	for (i = 1; i <= x[0]; i++)
	{
		x[i + 1] += x[i] / 10;
		x[i] %= 10;
	}
	while (x[i] > 0)//超过原数组最大位数继续进位直至不能再进
	{
		x[i + 1] += x[i] / 10;
		x[i++] %= 10;
	}
	x[0] = i - 1;//记录最后位数
}
/********************************************************
	带余除法
	利用移位来模拟试除
	注意被除数比除数小的话全零的情况
*********************************************************/
void divide(int x[], int y[], int z[])//构造试除的被减数
{
	if (!compare(x, y))//被除数小于除数商为0
	{
		z[0] = 1;
		return;
	}
	int gap = x[0] - y[0], i;//得到数位差
	while (gap >= 0)
	{
		int i, temp[N] = { 0 }, j = 0;
		for (i = y[0]; i > 0; i--)
			temp[i + gap] = y[i];
		temp[0] = y[0] + gap;//构造试除的被除数
		while (compare(x, temp))//循环减，以获得商在该位上的数
		{
			minus(x, temp);
			j++;
		}
		z[gap + 1] = j;
		gap--;
	}
	int flag = 1;
	for (i = x[0]; i > 0; i--)//取得商的位数
		if (z[i] != 0)
		{
			flag = 0;
			z[0] = i;
			break;
		}
	if (flag)z[0] = 1;
}
/********************************************************
	大数高精阶乘（还不够快！）
*********************************************************/
void factorial(int ans[],int n)
{
	int i;
	for (i = n - 1; i >= 1; i--)
		single_precision_multiply(ans, i);
}
/********************************************************
	小数除法
	先提高精度，再标记小数点即可
*********************************************************/
void divide_decimal(int x[], int y[],int z[],int precision)
{
	int gap, i, flag = 1;//先把精度满足再除
	for (i = x[0]; i > 0; i--)
		x[i + precision + 1] = x[i];
	memset(x + 1, 0, sizeof(int)*precision);
	z[0] = x[0] += precision + 1;//这里要加1，给小数点留个位置
	gap = x[0] - y[0];
	while (gap >= 0)//以下是正常的带余除法
	{
		int temp[N] = { 0 }, j = 0;
		for (i = y[0]; i > 0; i--)
			temp[i + gap] = y[i];
		temp[0] = y[0] + gap;
		while (compare(x, temp))
		{
			minus(x, temp);
			j++;
		}
		z[gap + 1] = j;
		gap--;
	}
	for (i = 1; i <= precision; i++)
		z[i] = z[i + 1];
	z[precision + 1] = -1;//标记小数点的位置
	for (i = z[0]; i > 0; i--)//规范整数数位	
		if (z[i] > 0)
		{
			flag = 0;
			z[0] = i;
			break;
		}
		else if (z[i] == -1)//如果正好第一个碰到小数点，则位数加一
		{
			flag = 0;
			z[0] = i + 1;
			break;
		}
	if (flag)z[0] = 1;
}
